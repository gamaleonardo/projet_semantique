-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;
inh tam : IMachine for
         PROGRAMME, ENTITES, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, TYPE, STYPE, PTRS,
         E, AFFX, A, AX, R, RX, T, TX, F,FX
         ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
syn code : STRING for 
         ENTITES, ENTITE, FONCTION, INST, BLOC, INSTS, SIX,
         TYPE, STYPE, PTRS,
         ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX,FX, OPREL, OPADD, OPMUL, OPUN,F 
         ;
inh hcode : STRING for PTRS, F, FX;

-- la TDS courante
inh tds_asm : TDS for ASM;

inh tds : TDS for 
         ENTITES,ENTITE, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX,DECL, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
         ;

syn type : DTYPEImpl for TYPE, STYPE, PTRS, FONCTION, INST, BLOC, INSTS, SIX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX;
syn params : PARAMETRES for PARFS, PARFSX, ESX, ES;
inh hparams: PARAMETRES for PARF, PARFSX, E, ES, ESX, FX, F , T , R,A ;

inh htype: DTYPE for PTRS, F, FX;
inh htyp: DTYPE for BLOC, INST, INSTS, SIX ;



syn dep :   INTEGER for INST, INSTS, BLOC, FONCTION,ENTITES,PARFS,PARF,PARFSX, SIX;
inh hdep : INTEGER for INST, INSTS, BLOC, ENTITES, FONCTION,PARFS,PARF,PARFSX, SIX, PTRS;     

syn code_est_adresse : BOOLEAN for  F, FX ;
inh hcode_est_adresse : BOOLEAN for FX ;
syn adresse : INTEGER for  F, FX ;
inh hadresse : INTEGER for F, FX ;

--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

--production rules
PROGRAMME -> #init ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
    tds : TDS;
#init {
local
do
  
   ENTITES^tam := new MTAM();
   ENTITES^hdep:=new Emplacement(0, new Register("SB",1));  
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
  tds := new TDS();
  ENTITES^tds := tds;
end
}
-- ecrit le code dans un fichier
#gen {
local
    tam : IMachine;
do
   tam := new MTAM();
   if (tds.chercherLocalement("main")= null) then
       error(no_main);
   else
        machine.writeCode(PROGRAMME^source.getFileName(), tam.genCall("main")+ENTITES^code);
  end 
end
}

ENTITES -> #dep;
#dep{
do
    ENTITES ^dep:=ENTITES^hdep;
    ENTITES^code := "";
 end}
 

ENTITES -> ENTITE ENTITES ;
-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc pv #tds ;
-- definition d'une variable globale ou d'une fonction
-- (commence par une minuscule)
  #tds{
  local 
    i: INFO;
  do
  i := ENTITE^tds.chercherLocalement(identc^txt);
   if i /= null then
      error(ident_existe_deja, identc^txt);
     end
  
  
 end }
ENTITE ->  TYPE ident DECL ;
-- Variable
DECL -> pv;
DECL -> #tds FONCTION ;
#tds{
do
    FONCTION^tds := DECL^tds;
end
}
-- Fonction
FONCTION ->  paro PARFS #init parf  BLOC #tdstype ;
#init{
do
 --   FONCTION^code := FONCTION^tam.genXXXX(xxxx); --TYPE^type.getTaille()
end}
#tdstype{
local
    i:INFO;
    ifonc : INFOFONC;
do
    --i := FONCTION^tds.chercherLocalement(xxxxx); --ident^txt
    --if i /= null then
     -- error(la_fonction_existe_deja, xxxxx);
      --else
      -- creer une variable      ??????? problème pas d'acces a Type^type dans la déclaration ?
      --ifonc := new INFOFONC(TYPE^type, FONCTION^hdep, PARFS^params); --initialiser deplacement
     -- FONCTION^tds.inserer(ident^txt,  ifonc);
      --end
 end}
-- PARAMETRES de fonctions
PARFS ->#param;
#param{
do
    PARFS^params := new PARAMETRES();
    PARFS^dep:=PARFS^hdep;
end}
PARFS -> #init PARF #hdep PARFSX #fin;
#init{
local
    p : PARAMETRES;
do
    p := new PARAMETRES();
    PARF^hparams := p;
    PARFSX^hparams := p;
    PARF^hdep:=PARFS^hdep;
end}
#hdep{
do 
   PARFSX^hdep:=PARF^dep;
end}
#fin{
do
    PARFS^params := PARFSX^params;
    PARFS^dep:=PARFSX^dep;
end}


PARFSX -> #end;
#end{
do
    PARFSX^params := PARFSX^hparams;
    PARFSX^dep:=PARFSX^hdep;
end}

PARFSX ->  virg #hd1 PARF #hd2 PARFSX #fin;
#hd1{
do
   PARF^hdep:=PARFSX^hdep;
   end}
#hd2{
do
   PARFSX1^hdep:=PARF^dep;
   end}
#fin{
do
    PARFSX^params := PARFSX1^params;
    PARFSX^dep:=PARFSX1^dep;
end
}

PARF ->  TYPE ident #tdstype ;

#tdstype{
local
    t : DTYPE;
    iv : INFOVAR;
do
    t := PARF^hparams.getParametre(ident^txt);
    if (t = null) then
     iv := new INFOVAR(xxxxxx);
    end
 end
}
-- les types (de base, noms, struct et pointeurs)
TYPE -> STYPE  #htype PTRS #type;
#htype{
do 
  PTRS^htype:= STYPE^type;
  PTRS^hcode := "";
end}
#type {
do
  TYPE^type := PTRS^type;
   if (PTRS^code="")then
     TYPE^code := STYPE^code;
  else
     TYPE^code := PTRS^code;
  end
end}

-- type de base
-- des * pour definir un pointeur
PTRS -> #type;
#type{
do
    PTRS^type := PTRS^htype;
    --PTRS^code := PTRS^hcode + ????
end}

PTRS -> mult #gencode PTRS #type;
#gencode {
do
     -- il faut verifié si les params sont déclaré : il faut ajouté un attribut hérité??????
     PTRS1^hcode := PTRS^hcode+PTRS^tam.genMalloc(1);

end}
#type {
do
  PTRS^type := new POINTEUR(PTRS1^type);
  PTRS^code := PTRS1^code;
end}

-- types de base
STYPE-> void  #type ;
#type{
do
    STYPE^type := new DTYPEImpl("void", 0);
    STYPE^code := ""; --STYPE^tam.genXXXXXX(1); 
end
}
STYPE-> int #type;
#type{
do
    STYPE^type := new DTYPEImpl("entier", 1);
    STYPE^code := ""; --STYPE^tam.genXXXXXX(1);
end
}
STYPE-> char #type;
-- nom de type (commence par une majuscule)
#type{
do
    STYPE^type := new DTYPEImpl("caractere", 1);
    STYPE^code := ""; --STYPE^tam.genXXXX(1);
  
end
}
STYPE -> identc #type;
-------------  
-- et struct
#type{
do
    STYPE^type := new DTYPEImpl("caracteretc", 1);
    STYPE^code := STYPE^tam.genXXXX(1);
  
end
}
STYPE -> struct aco CHAMPS acf ;     --?????? Nader 
CHAMPS -> ;
-- un nom de champ commence par une minuscule
CHAMPS -> CHAMP CHAMPS ;
CHAMP -> TYPE ident pv;

-- corps de fonction et bloc d'instructions
BLOC ->  aco #tds INSTS #type acf ;
-- instructions
#tds{
do
    INSTS^tds := new TDS(BLOC^tds);
    INSTS^hdep:=BLOC^hdep;
end
}
#type{
do
  BLOC^type := INSTS^type;
  BLOC^dep:=INSTS^dep;
end}

INSTS -> #type  ;
#type{
do 
  INSTS^type:=new DTYPEImpl("void",0);
  INSTS^dep:=INSTS^hdep;
end}

INSTS -> #htype INST #hdep INSTS #type  ;
-- declaration de variable locale avec ou sans init 
#htype{
do
INST^htyp:=INSTS^htyp;
INSTS1^htyp:=INSTS^htyp;
INST^hdep:=INSTS^hdep;
end}
#hdep{
do
  INSTS1^hdep:=INST^dep;
end}
#type{
local
    s : STRING;
do
    s := INST^type.getNom();
    if s.equals("void")then
        INSTS^type := INSTS1^type;
    else
        INSTS^type := INST^type; --type de premier INST non void rencontre
    end
    INSTS^dep:=INSTS1^dep;
end}

INST ->  TYPE ident AFFX pv ;
-- instruction expression (affectation et appel de procedure)
INST -> #params E pv #r ;
#params{
do
  E^hparams:=new PARAMETRES();
  INST^dep:=INST^hdep;
 
 end}
#r{
do
 INST^type := new DTYPEImpl("void", 0);
 if ~(E^type.compareTo(new DTYPEImpl("void",0))) then
    error(pas_instruction, E^type);
 end
 INST^code := E^code;
 INST^dep := new Emplacement(INST^hdep.getDep() + E^type.getTaille(), INST^hdep.getReg());
end}

-- bloc d'instructions
INST -> #tds BLOC #type  ;
#tds{
do
    BLOC^tds := new TDS(INST^tds);
    BLOC^hdep:=INST^hdep;
end
}
#type{
do
 INST^type := BLOC^type;
 INST^dep:=BLOC^dep;
 INST^code := BLOC^code;
end}
-- conditionnelle
INST ->   si paro E parf #tds BLOC SIX ;
#tds{
do
    BLOC^tds := new TDS(INST^tds);
    SIX^tds := new TDS(INST^tds);
    BLOC^htyp:=INST^htyp;
    SIX^htyp:=INST^htyp;
    BLOC^hdep:=INST^hdep;
    SIX^hdep:=INST^hdep;
end
}
SIX ->   sinon #hdep BLOC #r ;
#hdep{
do
 BLOC^hdep:=SIX^hdep;
end}
#r{
do
     SIX^type := BLOC^type;
     SIX^dep:=BLOC^dep;
    
end}   

SIX -> #type;
#type{
do
     SIX^type := new DTYPEImpl ("void",0);
     SIX^dep:=SIX^hdep;
     SIX^code := "";
end}

-- retour de fonction
INST ->  retour  #hparam E pv #r ;
#hparam{
do 
    E^hparams:=new PARAMETRES();
end}
#r{
do
     INST^type := E^type;
     INST^dep:=new Emplacement(INST^hdep.getDep()+E^type.getTaille(), INST^hdep.getReg());
     INST^code := E^code + INST^tam.genRetour();   -- code : empiler E 
end}

-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------
E ->   A  AFFX #r ;
#r{
do
 if AFFX^type.compareTo(new DTYPEImpl("void", 0)) then
     E^type := A^type;  
     E^code := A^code;
 elseif A^type.compareTo(AFFX^type) then
     E^type := A^type;
     E^code := AFFX^code  + E^tam.genWriteIndirectMem(A^type.getTaille()); ---- A^code
 else
      error(pas_meme_type, A^type); 
 end
 
end}

-- affectation
AFFX -> affect A #r;
#r{
do
    AFFX^type:=A^type;
    AFFX^code := A^code;
end}

AFFX -> #r;
#r{
do
    AFFX^type:=new DTYPEImpl("void",0);
    AFFX^code := "";
end}

-- relation
A ->   R AX #r;
#r{
do
 if AX^type.compareTo(new DTYPEImpl("void", 0)) then
     A^type := R^type;   
     A^code := R^code;
 elseif R^type.compareTo(AX^type) then
     A^type := R^type;
     A^code := R^code + AX^code;
 else
      error(pas_meme_type, R^type);
 end
end}

AX -> OPREL R #r;
#r{
do
    if R^type.compareTo(new DTYPEImpl("entier",1)) || R^type.compareTo(new DTYPEImpl("caractere",1))  then 
        AX^type:=R^type;
        AX^code := R^code + OPREL^code;
    else
        error(pas_reel, R^type); 
 end
 end}
AX -> #r ;
#r{
do
    AX^type:=new DTYPEImpl("void",0);
    AX^code := "";
 end} 
 
-- operateurs relationnels
OPREL -> inf #gen;
#gen{
do
    OPREL^code := "\tSUBR Lss \n";
end}

OPREL -> sup #gen;
#gen{
do
    OPREL^code := "\tSUBR Gtr \n";
end}

OPREL -> infeg #gen;
#gen{
do
    OPREL^code := "\tSUBR Leq \n";
end}

OPREL -> supeg #gen;
#gen{
do
    OPREL^code := "\tSUBR Geq \n";
end}

OPREL -> eg #gen;
#gen{
do
    OPREL^code := "\tSUBR Eq \n";
end}

OPREL -> neg #gen;
#gen{
do
    OPREL^code := "\tSUBR Neq \n";
end}
R ->  T  RX #r ;
#r{
do
 if RX^type.compareTo(new DTYPEImpl("void", 0)) then
     R^type := T^type; 
     R^code := T^code ;
 elseif RX^type.compareTo(T^type) then
     R^type := T^type;
     R^code := T^code + RX^code;
     
 else
      error(add_type_diff, T^type); 
 end
end}
-- additions ...
RX ->   OPADD  T RX #r ;
#r{
do
    if T^type.compareTo(new DTYPEImpl("entier",1))  then   
       if RX1^type.compareTo(new DTYPEImpl("void", 0)) then
          RX^type := T^type;  
          RX^code := T^code ; --+ OPADD^code
       elseif RX1^type.compareTo(T^type) then
          RX^type := T^type;
          RX^code := T^code + RX1^code + OPADD^code;
        else
          error(types_diff, RX1^type);
       end 
    else
  error(add_non_reels, T^type); 
 end
 end}
RX -> #r ;
#r{
do
    RX^type:=new DTYPEImpl("void",0);
    RX^code := "";
 end}
-- operateurs additifs
OPADD -> plus #gen;
#gen{
do
    OPADD^code := "\tSUBR Add \n";
end}

OPADD -> moins #gen;
#gen{
do
    OPADD^code := "\tSUBR Sub \n";
end}

OPADD -> ou #gen;
#gen{
do
    OPADD^code := "\tSUBR Or \n";
end}

-- multiplication, ...
T ->  F  TX #r ;
#r{
do
 if TX^type.compareTo(new DTYPEImpl("void", 0)) then
     T^type := F^type;  
     T^code := F^code ;
 elseif TX^type.compareTo(F^type) then
     T^type := F^type;
     T^code := F^code + TX^code;
 else
      error(mulTypes_diff, F^type); 
 end
end}
TX ->   OPMUL   #hp F TX #r ;
#hp{
do
  F^hparams:=new PARAMETRES();
end
}
#r{
do
    if F^type.compareTo(new DTYPEImpl("entier",1)) then
       if TX1^type.compareTo(new DTYPEImpl("void", 0)) then
          TX^type := F^type;  
          TX^code := F^code; --+ OPMUL^code
       elseif TX1^type.compareTo(F^type) then
          TX^type := F^type;
          TX^code := F^code +  TX1^code + OPMUL^code;
       else
          error(mult_types_diff, TX1^type); 
       end 
    else
        error(pas_reel, F^type); 
 end
 end}
TX ->  #r ;
#r{
do
    TX^type:=new DTYPEImpl("void",0);
    TX^code := "";
 end}
-- operateurs multiplicatifs
OPMUL -> mult #gen ;
#gen{
do
    OPMUL^code := "\tSUBR Mul \n";
end}
OPMUL -> div #gen ;
#gen{
do
    OPMUL^code := "\tSUBR Div \n";
end}
OPMUL -> mod #gen ;
#gen{
do
    OPMUL^code := "\tSUBR Mod \n";
end}
OPMUL -> et #gen ;
#gen{
do
    OPMUL^code := "\tSUBR And \n";
end}
-- expressions de base
-- Constante entiere
F -> entier #type;
#type{
do
   F^type := new DTYPEImpl("entier", 1);
   F^code := F^tam.genCst(entier^txt);
   F^code_est_adresse := false;
   F^adresse := -1;
end
}  
-- Constante chaine
F -> chaine #type;
#type{
do
   F^type := new DTYPEImpl("entier", 1);
   F^code := F^tam.genCst(chaine^txt); 
   F^code_est_adresse := false;
   F^adresse := -1;
end
}  
-- Constante caractere
F -> caractere #type;
#type{
do
   F^type := new DTYPEImpl("entier", 1);
   F^code := F^tam.genCst(caractere^txt); 
   F^code_est_adresse := false;
   F^adresse := -1;
end
}  
-- expression unaire
F ->  OPUN  F  #gen;
#gen{
do
    F^type := F1^type;
    F^code := F1^code + OPUN^code;
    F^code_est_adresse := false;
    F^adresse := -1;
end
}
-- operateurs unaires
OPUN -> plus #gen;
#gen{
do
    OPUN^code  := "\tSUBR Add \n";
end
}
OPUN -> moins #gen;
#gen{
do
    OPUN^code  := "\tSUBR Sub \n";
end
}
OPUN -> non#gen;
#gen{
do
    OPUN^code  := "\tSUBR Not \n";
end
}
-- pointeur NULL
F -> null  #gen;
#gen{
do
   F^type := new DTYPEImpl("void",1);
   F^code_est_adresse := false;
   F^adresse := -1;
   F^code := "";
end
}
-- expression parenthesee
--F ->  paro E parf FX ;
F -> paro TYPE parf  F #gen;      --cast ??? nader
--#dec{
--do
    -- TYPE^hdep := new Emplacement(0, new Register("SB", 0));   --classe Emplacement dans mcsgc | Pas d'emplacements pour un type (Maxime)
--end}
--#gen{       --nader
--do
  -- if (F1^type.getTaille()=TYPE^type.getTaille()) then
    --   F^type:=TYPE^type; 
      -- F^code:= F1^code;
   --else error(cast_diff_taille, F1^type); 
--end
--end}
#gen{
do
    if F1^type.compareTo(TYPE^type) then
        F^type := TYPE^type;
        F^code_est_adresse := F1^code_est_adresse ;
        F^adresse := F1^adresse;
        F^code := F1^code;
    else
        error(Wrong_Type, F1^type);
    end
end
}
F -> mult #a  F #gen;
#gen {
do
  F^type := F1^type;
  F^code_est_adresse := true;
  F^code :=  F1^code;
  F^adresse := F1^adresse;
end
}

#a {
local
p : POINTEUR ;
code : STRING;
do
  match F^htype
  with POINTEUR then
    p := F^htype;
    F1^htype := p.getType();
    -- on lit le contenu
    --FX1^hcode_est_adresse := FX^hcode_est_adresse;
    code := F^tam.genComment("acces zone pointee : ");
    if F^hadresse != -1 then
      code := code + F^tam.genReadMem(F^hadresse, p.getTaille());
    else
      code := code + F^hcode + F^tam.genReadIndirectMem(1);
    end
    F1^hcode := code ;
    -- A partir de la, l'adresse n'est plus gerable             
    F1^hadresse := -1;
   else
    error(B_11, F^htype);
  end
end
}

F -> ident #h FX #gen;
#gen {
local
    i : INFO;
    c : DTYPE;
do
    i := F^tds.chercherGlobalement(ident^txt);
    if i /= null then
        match i with INFOVAR then
            c := i.getType();
            F^type := c;
            F^code_est_adresse := true; -- ou true ?
            F^code := F^tam.genAdr(i.getDep());
        end
        match i with INFOFONC then
        end
    end
end
}
#h {
local
 s : STRUCT ;
 c : CHAMP;
 lc : LCHAMPS;
do
  match FX^htype with STRUCT then
  end
end
}

FX ->#gen ;
#gen {
do
  FX^type := FX^htype;
  FX^code_est_adresse := FX^hcode_est_adresse;
  FX^code := FX^hcode; -- non vide !!
  FX^adresse := FX^hadresse;
end
}
-- acces champ
FX -> pt ident #h FX  #gen;
#h {
local
 s : STRUCT ;
 c : CHAMP;
 lc : LCHAMPS;
do
  match FX^htype
  with STRUCT then
    s := FX^htype;
    lc := s.getChamps();
    c := lc.chercher(ident^txt);
    if c = null then
      error(Unaffected_ident, ident^txt) ;
    else
      FX1^htype := c.getType();        
      FX1^hcode_est_adresse := false;
      FX1^hcode := FX^hcode +  FX^tam.genAdrField(c.getDep()) ;
     -------------------------------------------------------
    end    
  else
    error(Wrong_type, FX^htype);
  end

end
}

#gen {
do
  FX^type := FX1^type;
  FX^code_est_adresse := true;
  FX^code :=FX1^code;
  FX^adresse := FX1^adresse;
end
}


-- acces champ pointeur
FX ->   arrow  ident FX ;
-- appel de sous-programme
FX ->   paro ES parf FX ;

-- arguments appel de sous-programme
ES -> #p;
#p{
do
    ES^params := new Parametres();
    ES^code := "";
end}
ES -> #init E ESX #gen;
#init{
local
   p : Parametres;
do
    p := new Parametres();
    E^hparams := p;
    ESX^hparams := p;
end}
#gen{
do
    ES^params := ESX^params;
    ES^code := E^code + ESX^code;
end}
ESX ->  #gen ;
#gen{
do
   ESX^params:= ESX^hparams;
   ESX^code := "";
   end
}

ESX -> virg E ESX #gen ;
#gen{
do
   ESX^params:=ESX1^params;
   ESX^code := E^code + ESX1^code;
end}
------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur TAM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := ENTITE^tds; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
  ENTITE^code := ASM^code_asm;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := INST^tds;
  INST^dep:=INST^hdep;        --nader
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
  INST^dep:=INST^hdep;      --nader
  INST^code := ASM^code_asm;
  INST^type := new DTYPEImpl("void", 0); -- si il ya du code assembleur le type de retour est void
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
