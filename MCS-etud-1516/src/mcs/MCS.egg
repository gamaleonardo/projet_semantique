-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- la TDS courante
inh tds_asm : TDS for ASM;

inh tds : TDS for 
         ENTITES,ENTITE, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX,DECL, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
         ;
syn type : DtypeImpl for TYPE, STYPE, PTRS, FONCTION, INST, BLOC, INSTS, SIX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX,AFFX;
syn params : Parametres for PARFS, PARFSX, ESX, ES, FX;
inh hparams: Parametres for PARF, PARFSX, E, ES, ESX, FX, F , T , R , A;

inh htype: DtypeImpl for PTRS, FX, AFFX;
inh htyp: DTYPE for BLOC, INST, INSTS, SIX ;
syn dep :   Emplacement for INST, INSTS, BLOC, FONCTION,ENTITE, ENTITES,PARFS,PARF,PARFSX, SIX,TYPE, CHAMPS, CHAMP, DECL;
inh hdep : Emplacement for INST, INSTS, BLOC,ENTITE, ENTITES, FONCTION,PARFS,PARF,PARFSX, SIX, TYPE, PTRS, CHAMPS, CHAMP, DECL,AFFX,E;     

inh champs : DTYPE for CHAMPS, CHAMP;
syn code : String for INSTS, INST, ENTITES, ENTITE;
inh declid : STRING for DECL,FONCTION;
inh declt : STRING for DECL,FONCTION;
inh infonc : INFOFONC for BLOC;




--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

--production rules
PROGRAMME -> #init ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
  ENTITES^tds := new TDS();
  ENTITES^hdep:=0;
end
}
-- ecrit le code dans un fichier
#gen {
local
do  --if faut chercher le main existe ou pas
    --if (ENTITES^std.chercherLocalement("main")= null) then
    -- error(main_nexiste_pas);
    
      machine.writeCode(PROGRAMME^source.getFileName(),"; no code\n");  
end
}
ENTITES -> #gen;
#gen {
do
ENTITES^dep:=ENTITES^hdep;
ENTITES^code:="";
end
}


ENTITES ->  #dep1 ENTITE #dep ENTITES #gen;
#dep1{
do
ENTITE^hdep:=ENTITES^hdep;
end
}


#dep{
do

ENTITES1^hdep:=ENTITE^dep;
end}
#gen{
do
ENTITES^dep:=ENTITES1^dep;
ENTITES^code:=ENTITE^code + ENTITES1^code;
end}


-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc pv #tds ;
-- definition d'une variable globale ou d'une fonction
-- (commence par une minuscule)
  #tds{
  local 
    i: INFO;
  do
  i := ENTITE^tds.chercherLocalement(identc^txt);
   if i /= null then
      error(ident_existe_deja, identc^txt);
   end
   -- defintion d'un nouveau type
   i:= new INFOTYPE(TYPE^type);
   ENTITE^tds.inserer(identc^txt,i); 
   ENTITE^dep:=ENTITE^hdep;
   ENTITE^code:="";
   
     
end }

ENTITE ->  TYPE ident #tds DECL #gen;

#tds{
do
DECL^declid:=ident^txt;
DECL^declt:=TYPE^type;
DECL^tds:=ENTITE^tds;
DECL^hdep:=ENTITE^hdep;
end}

#gen{
  local 
    i: INFO;
  do
  i := ENTITE^tds.chercherLocalement(ident^txt);
   if i /= null then
      error(ident_existe_deja, ident^txt);
   end
 ENTITE^dep:= DECL^dep;  
 -- i := ENTITE^tds.chercherLocalement(ident^txt);
 --  if i /= null then
 --       match DECL^type with FONCTION then
 --                 error(ident_existe_deja, ident^txt); -- il s'agit d'une fonction donc traitement de la surcharge (nombre de paramétres différents avec le meme nom de fonction)
 --       else
 --                 error(ident_existe_deja, ident^txt);
 --       end                                    
 --  end
end}


-- Variable
DECL -> pv #tds_type;

#tds_type{
local 
 i:INFOVAR;
do
i := DECL^tds.chercherLocalement(DECL^declid);
if (i/=null) then
 error(ident_existe_deja, DECL^declid);
else
-- creation dune nouvelle variable et ajout dans la table des symboles
 i:= new INFOVAR(DECL^declt,DECL^hdep);
 call DECL^tds.inserer(DECL^declid,i);
 DECL^dep:= DECL^hdep + DECL^declt.getTaille();
end 
end}


DECL -> #tds FONCTION #dep ;
#dep{
do
DECL^dep:=FONCTION^dep;
end}
#tds{
do
     FONCTION^declid:=DECL^declid;
     FONCTION^declt:=DECL^declt;
     FONCTION^tds := DECL^tds;
end
}
-- Fonction
FONCTION ->  paro PARFS parf #tds BLOC #tdstype ;
global
ifonc:INFOFONC;
#tds{
local
tds:TDS;
do
tds:=new TDS(FONCTION^tds);
ifonc:= new INFOFONC(FONCTION^declt,null,PARFS^params,tds);
FONCTION^tds.inserer(FONCTION^declid,ifonc);
BLOC^infonc:=ifonc;
BLOC^hdep:=PARFS^dep;
end
}
#tdstype{
do
 FONCTION^dep:=BLOC^dep;    
    --i := FONCTION^tds.chercherLocalement(xxxxx); --ident^txt
    --if i /= null then
     -- error(la_fonction_existe_deja, xxxxx);
      --else
      -- creer une variable      ??????? problème pas d'acces a Type^type dans la déclaration ?
      --ifonc := new INFOFONC(TYPE^type, FONCTION^hdep, PARFS^params); --initialiser deplacement
     -- FONCTION^tds.inserer(ident^txt,  ifonc);
      --end
end}
-- parametres de fonctions
PARFS ->#param;
#param{
do
    --PARFS^params := new Parametres();   nader
    --PARFS^dep:=PARFS^hdep;
    PARFS^params :=null;
    PARFS^dep:=PARFS^hdep;
end}
PARFS -> #init PARF #hdep PARFSX #fin;
#init{
local
    p : Parametres;
do
    p := new Parametres();
    PARF^hparams := p;
    PARFSX^hparams := p;
    PARF^hdep:=PARFS^hdep;
end}
#hdep{
do 
   PARFSX^hdep:=PARF^dep;
end}
#fin{
do
    PARFS^params := PARFSX^params;
    PARFS^dep:=PARFSX^dep;
end}


PARFSX -> #end;
#end{
do
    PARFSX^params := PARFSX^hparams;
    PARFSX^dep:=PARFSX^hdep;
end}

PARFSX ->  virg #hd1 PARF #hd2 PARFSX #fin;
#hd1{
do
   PARF^hdep:=PARFSX^hdep;
   end}
#hd2{
do
   PARFSX1^hdep:=PARF^dep;
   end}
#fin{
do
    PARFSX^params := PARFSX1^params;
    PARFSX^dep:=PARFSX1^dep;
end
}

PARF ->  TYPE ident #tdstype ;
-- les types (de base, noms, struct et pointeurs)
#tdstype{
local
    t : DTYPE;
    iv : INFOVAR;
do
    t := PARF^hparams.getParametre(ident^txt);
    if (t = null) then
       iv := new INFOVAR(TYPE^type,TYPE^dep);
       PARF^hparams.inserer(ident^txt,iv);
    else
        error(parametre_existe_deja, ident^txt);
    end
    PARF^dep:=PARF^hdep + TYPE^type.getTaille();
 end
}
TYPE -> STYPE  #htyp PTRS #type;
-- type de base
-- des * pour definir un pointeur
#htyp{
do 
  PTRS^htype:= STYPE^type;
end}
#type {
do
  TYPE^type := PTRS^type;
end}

PTRS -> #type;
#type{
do

    PTRS^type := PTRS^htype;
end}

PTRS -> mult PTRS #type;
-- types de base
#type {
do
  PTRS^type := new POINTEUR(PTRS1^type);
  --PTRS^code := PTRS1^code;
end}

STYPE-> void  #type ;
#type{
do
    STYPE^type := new DtypeImpl("void", 0);
end
}
STYPE-> int #type;
#type{
do
    STYPE^type := new DtypeImpl("entier", 1);
end
}
STYPE-> char #type;
-- nom de type (commence par une majuscule)
#type{
do
    STYPE^type := new DtypeImpl("caractere", 1);
  
end
}
STYPE -> identc #type;
-------------  
-- et struct
#type{
do
    STYPE^type := new DtypeImpl("caracteretc", 1);
  
end
}
STYPE -> struct #1 aco CHAMPS acf #2  ;
global
lt : LCHAMPS;
#1{
do
    lt := new LCHAMPS();    
    CHAMPS^champs :=lt;
    CHAMPS^hdep:=0; 
end
}
#2{
do
    STYPE^type := new STRUCT(lt);
    -- a completer generation de code
end
}
 
CHAMPS -> #dep ;
#dep{
do
CHAMPS^dep:=CHAMPS^hdep;
end}

-- un nom de champ commence par une minuscule
CHAMPS -> CHAMP #4 CHAMPS #5 ;
#5{
do
CHAMPS^dep:= CHAMPS1^dep;
end}


#4{
do
CHAMPS1^hdep:=CHAMP^dep;
end
}
CHAMP -> TYPE ident pv #3;
#3{
local
it:CHAMP;
do
        it:=CHAMP^champs.chercher(ident^txt);
        if (it/=null) then
           error(pram_exist,ident^txt);        
        else
        it:= new CHAMP(ident^txt, TYPE^type, CHAMP^hdep);
        CHAMP^champs.inserer(it);
        CHAMP^dep:= CHAMP^hdep + TYPE^type.getTaille();     
        end
    -- a completer generation de code
end
}



-- corps de fonction et bloc d'instructions
BLOC ->  aco #tds INSTS #type acf ;
-- instructions
#tds{
do
    
    INSTS^tds := BLOC^infonc.getTDS();
    INSTS^hdep:=BLOC^hdep;
end
}
#type{
do
  BLOC^type := INSTS^type;
  BLOC^dep:=INSTS^dep;
end}

INSTS -> #gen  ;
#gen{
do 
  INSTS^code:="";
  INSTS^dep:=INSTS^hdep;
end}

INSTS -> #htype INST #hdep INSTS #gen  ;
-- declaration de variable locale avec ou sans init 
#htype{
do
INST^htyp:=INSTS^htyp;    -- inutile car la transmission se fait automatiquement (MA)
INSTS1^htyp:=INSTS^htyp;
INST^hdep:=INSTS^hdep;
end}
#hdep{
do
  INSTS1^hdep:=INST^dep;
end}
#gen{
local
    s : STRING;
do
    s := INST^type.getNom();
    if s.equals("void")then
        INSTS^type := INSTS1^type;
    else
        INSTS^type := INST^type; --type de premier INST non void rencontre
    end
    INSTS^dep:=INSTS1^dep;
    INSTS^code:=INST^code + INSTS1^code;
    
    
    
end}

INST ->  TYPE ident  AFFX pv #tds ;
#tds{
local
i: INFO;

do
  i := INST^tds.chercherLocalement(ident^txt);
   if i /= null then
      error(ident_existe_deja, ident^txt);
   end
   -- defintion d'un nouveau type
   i:= new INFOVAR(TYPE^type,null);
   INST^tds.inserer(ident^txt,i); 
   if ~(TYPE^type.compareTo(AFFX^type)) then
        error(pas_instruction, TYPE^type);
   end
   INST^dep:= INST^hdep + TYPE^type.getTaille(); 
end}





-- instruction expression (affectation et appel de procedure)
INST -> #params E pv #r ;
#params{
do
  E^hparams:=new Parametres();
  INST^dep:=INST^hdep;
 
 end}
#r{
do
 INST^type := new DtypeImpl("void", 0);
 if ~(E^type.compareTo(new DtypeImpl("void",0))) then
    error(pas_instruction, E^type);
 end
 INST^dep := new Emplacement(INST^hdep.getDep() + E^type.getTaille(), INST^hdep.getReg());
end}

-- bloc d'instructions
INST -> #tds BLOC #type  ;
-- conditionnelle
#tds{
do
    BLOC^tds := new TDS(INST^tds);
    BLOC^hdep:=INST^hdep;
end
}
#type{
do
 INST^type := BLOC^type;
 INST^dep:=BLOC^dep;
end}

INST ->   si paro E parf #tds BLOC SIX ;
#tds{
do
    BLOC^tds := new TDS(INST^tds);
    SIX^tds := new TDS(INST^tds);
    BLOC^htyp:=INST^htyp;
    SIX^htyp:=INST^htyp;
    BLOC^hdep:=INST^hdep;
    SIX^hdep:=INST^hdep;
end
}
SIX ->   sinon #hdep BLOC #r ;
#hdep{
do
 BLOC^hdep:=SIX^hdep;
end}
#r{
do
     SIX^type := BLOC^type;
     SIX^dep:=BLOC^dep;
    
end}   

SIX -> #type;
#type{
do
     SIX^type := new DtypeImpl ("void",0);
     SIX^dep:=SIX^hdep;
end}

-- retour de fonction
INST ->  retour  E pv ;


-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------
E ->   A  #type AFFX #type2 ;
#type2{
do
    if ~(A^type.compareTo(AFFX^type)) then
        error(pas_instruction, A^type);
    end
end}
-- affectation
#type{
do
AFFX^htype := A^type;
AFFX^hdep:= A^type.getTaille() + E^hdep;
end}

AFFX -> affect  A #type ;
#type{
do
AFFX^dep:=A^dep;
if (A^type/=AFFX^type) then
   error(erreur_type,null);
end if
end}


AFFX -> ;
-- relation
A ->   R AX  ;
AX -> OPREL R;
AX ->  ;
-- operateurs relationnels
OPREL -> inf ;
OPREL -> sup ;
OPREL -> infeg ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;
R ->  T  RX ;
-- additions ...
RX ->   OPADD  T RX  ;
RX -> ;
-- operateurs additifs
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;
-- multiplication, ...
T ->  F  TX  ;
TX ->   OPMUL  F TX  ;
TX ->  ;
-- operateurs multiplicatifs
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;
-- expressions de base
-- Constante entiere
F -> entier   ;
-- Constante chaine
F -> chaine ;
-- Constante caractere
F -> caractere ;
-- expression unaire
F ->  OPUN  F  ;
-- operateurs unaires
OPUN -> plus ;
OPUN -> moins ;
OPUN -> non;
-- pointeur NULL
F -> null  ;
-- expression parenthesee
F ->  paro E parf FX ;
F ->  paro TYPE parf  F ;
F -> mult F ;
F -> ident FX ;
FX -> ;
-- acces champ
FX ->   pt  ident FX ;
-- acces champ pointeur
FX ->   arrow  ident FX ;
-- appel de sous-programme
FX ->   paro ES parf FX;
-- arguments appel de sous-programme
ES -> ;
ES -> E ESX  ;
ESX ->  ;
ESX -> virg E ESX ;

------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur T+++++++AM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := null; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
