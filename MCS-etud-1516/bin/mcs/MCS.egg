-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX,DEF,DEFS,BASE
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;
inh tam : MTAM for
         PROGRAMME, ENTITES, ENTITE, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, DECL,
         E, AFFX, A, AX, R, RX, T, TX, F,FX,DEF,DEFS,BASE
         ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- la TDS courante
inh tds_asm : TDS for ASM;


syn code : STRING for 
         ENTITES, ENTITE, FONCTION, INST, BLOC, INSTS, SIX,
         ES, ESX, DECL, -- ajoute attribut code a DECL Leonardo
         E, AFFX, A, AX, R, RX, T, TX,FX, OPREL, OPADD, OPMUL, OPUN,F,DEFS,DEF;
inh hcode : STRING for PTRS, F, FX;


inh tds : TDS for 
         ENTITES,ENTITE, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX,DECL, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX,STYPE,TYPE,CHAMP,CHAMPS,DEFS,DEF,BASE,HERITAGE, IDC
         ;
syn type : DTYPE for TYPE, STYPE, PTRS, FONCTION, INST, BLOC, INSTS, SIX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX;
inh htype: DTYPE for PTRS, FX, AFFX;
          
syn params : PARAMETRES for PARFS, PARFSX, ESX, ES;
inh hparams: PARAMETRES for PARFS, PARF, PARFSX, E, ES, ESX, FX, F;

syn dep :   Emplacement for INST, INSTS, BLOC, FONCTION,ENTITE, ENTITES,PARFS,PARF,PARFSX, SIX, CHAMPS, CHAMP, DECL,DEFS,DEF;
inh hdep : Emplacement for INST, INSTS, BLOC,ENTITE, ENTITES, FONCTION,PARFS,PARF,PARFSX, SIX, TYPE, PTRS, CHAMPS, CHAMP, DECL,STYPE,DEF,DEFS;     

inh champs : LCHAMPS for CHAMPS, CHAMP;
inh declid : STRING for DECL,FONCTION;
inh declt : DTYPE for DECL,FONCTION;
inh infonc : INFOFONC for BLOC;


syn code_est_adresse : BOOLEAN for  F, FX ;
inh hcode_est_adresse : BOOLEAN for FX ;
syn adresse : INTEGER for  F, FX ;
inh hadresse : INTEGER for  FX ;
inh valeurchargee : BOOLEAN for A, AX, R, RX, T, TX, F;

syn nms : NAMESPACE for IDC;
inh hnms : NAMESPACE for IDC;
----------------
inh hname: INFOCLASSE for IDC;
syn name : INFOCLASSE for HERITAGE, IDC;
syn acc : STRING for ACCES;
inh hattribut : ArrayList<String> for DEF,DEFS,DECL;
inh htv : ArrayList<String> for DEF,DEFS,DECL;
syn tv : ArrayList<String> for DEFS;

--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
sugar ref is "ref" ;
sugar out is "out";
sugar namespace is "namespace";
sugar using is "using";
sugar class is "class";
sugar public is "public" ;
sugar private is "private";
sugar dpts is "\:";
sugar bool is "bool";
sugar true is "true";
sugar false is "false";
sugar this is "this";
sugar new is "new" ;
sugar null2 is "null";
sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;


--production rules
PROGRAMME -> #init ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
    tds : TDS;
#init {
local
do 
    ENTITES^tam := new MTAM();
    ENTITES^hdep:=new Emplacement(0, new Register("SB",1));  
    machine := PROGRAMME^source.getMachine();
    if machine = null then
        error(NO_MACH, PROGRAMME^source.getMachName());
    else
       ENTITES^machine := machine;
    end
    tds := new TDS();
    ENTITES^tds := tds;
end}
-- ecrit le code dans un fichier
#gen {
local
    tam : MTAM;
do
    --write tds;
    tam := new MTAM();
    if (tds.chercherGlobalement("main")= null) then
        error(no_main);
    else
       machine.writeCode(PROGRAMME^source.getFileName(), tam.genCall("main")+ENTITES^code);
    end
end}


ENTITES -> #gen;
#gen {
do
    ENTITES^dep:=ENTITES^hdep;
    ENTITES^code:="";
end}
 

ENTITES ->  #dep1 ENTITE #dep ENTITES #gen;
#dep1{
do
    ENTITE^hdep:=ENTITES^hdep;
end}
#dep{
do
    ENTITES1^hdep:=ENTITE^dep;
end}
#gen{
do
    ENTITES^dep:=ENTITES1^dep;
    ENTITES^code:=ENTITE^code + ENTITES1^code;
end}


-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc pv #tds ;
#tds{
local 
    i: INFO;
do
    i := ENTITE^tds.chercherLocalement(identc^txt);
    if i /= null then
        error(ident_existe_deja, identc^txt);
    end
    -- defintion d'un nouveau type
    i:= new INFOTYPE(TYPE^type);
    ENTITE^tds.inserer(identc^txt,i); 
    ENTITE^dep:=ENTITE^hdep;
    ENTITE^code:="";  
end }


-- definition d'une variable globale ou d'une fonction
-- (commence par une minuscule)
ENTITE ->  TYPE ident #tds DECL #gen;
#tds{
local 
    i: INFO;
do
    DECL^declid:=ident^txt;
    DECL^declt:=TYPE^type;
    DECL^tds:=ENTITE^tds;
    DECL^hdep:=ENTITE^hdep;
    DECL^hattribut:=null;
    DECL^htv:=null;
    
    i := ENTITE^tds.chercherLocalement(ident^txt);
    if i /= null then
       match i
           with INFOFONC then
               error(Fonction_existe_deja, ident^txt); -- il s'agit d'une fonction donc traitement de la surcharge (nombre de paramétres différents avec le meme nom de fonction)
           else 
               error(ident_existe_deja, ident^txt);
       end                                    
    end
end}
#gen{
do
    ENTITE^dep:= DECL^dep;
    ENTITE^code :=DECL^code;  
end
}


-- Variable
DECL -> pv #tds_type;
#tds_type{
local 
    i:INFO;
do
    i := DECL^tds.chercherLocalement(DECL^declid);
    if (i/=null) then
        error(ident_existe_deja, DECL^declid);
    else
        -- creation d'une nouvelle variable et ajout dans la table des symboles
        i:= new INFOVAR(DECL^declt,DECL^hdep);
        call DECL^tds.inserer(DECL^declid,i);
        DECL^dep:= new Emplacement (DECL^hdep.getDep() + DECL^declt.getTaille(), DECL^hdep.getReg());
    end 
    DECL^code:=""; -- initialisation de variable 
   if (DECL^hattribut/=null) then
     DECL^hattribut.add(DECL^declid);
   end   
     
end}


DECL -> #tds FONCTION #dep ;
#dep{
do
    DECL^dep:=FONCTION^dep;
    DECL^code:=FONCTION^code; -- La declaration du code recoit le code de la fonction
    if (DECL^htv/=null) then
    	DECL^htv.add(DECL^declid);
    end   
    
    
    
end}
#tds{
do
    FONCTION^declid:=DECL^declid;
    FONCTION^declt:=DECL^declt;
    FONCTION^tds := DECL^tds;
    FONCTION^hdep := new Emplacement(-1, new Register("LB",0));
end}


-- Fonction
FONCTION ->  paro #param PARFS parf #tds BLOC #gen ;
global
    ifonc:INFOFONC;
#param{
do
PARFS^hparams:=new PARAMETRES();
PARFS^hdep:= new Emplacement (-1, FONCTION^hdep.getReg());

end}

#tds{
local
    tds:TDS;
do
    tds:=new TDS(FONCTION^tds);
    ifonc:= new INFOFONC(FONCTION^declt,null,PARFS^params,tds);
    FONCTION^tds.inserer(FONCTION^declid,ifonc);
    BLOC^infonc:=ifonc;    
end}
#gen{
do
    FONCTION^dep:=BLOC^dep;    
    FONCTION^type := BLOC^type;
    FONCTION^code := FONCTION^tam.genFonction(FONCTION^declid, 0, BLOC^type.getTaille(),BLOC^code); --A completer : enregistrer le type de retour
end}
 
 
 
-- PARAMETRES de fonctions
PARFS ->#param;
#param{
do
    --PARFS^params := new PARAMETRES();
    --PARFS^params :=null;
    PARFS^params:=PARFS^hparams; -- medali
    PARFS^dep:=PARFS^hdep;
end}


PARFS -> #init PARF #hdep PARFSX #fin;
#init{
local
    --p : PARAMETRES;
do
    --p := new PARAMETRES();
    --PARF^hparams := p;
    --PARFSX^hparams := p;
    PARF^hdep:=PARFS^hdep;
end}
#hdep{
do 
    PARFSX^hdep:=PARF^dep;
    
end}
#fin{
do
    PARFS^params := PARFSX^params;
    PARFS^dep:=PARFSX^dep;
end}


PARFSX -> #end;
#end{
do
    PARFSX^params := PARFSX^hparams;
    PARFSX^dep:=PARFSX^hdep;
end}


PARFSX ->  virg #hd1 PARF #hd2 PARFSX #fin;
#hd1{
do
   PARF^hdep:=PARFSX^hdep;
   end}
#hd2{
do
   PARFSX1^hdep:=PARF^dep;
   end}
#fin{
do
    PARFSX^params := PARFSX1^params;
    PARFSX^dep:=PARFSX1^dep;
end}


PARF ->  TYPE ident #tdstype ;
#tdstype{
local
    t : DTYPE;
    iv : INFOVAR;
do
    iv := PARF^hparams.getParametre(ident^txt);
    --t := iv.getType();
    if (iv = null) then
      -- iv := new INFOVAR(TYPE^type, new Emplacement(TYPE^type.getTaille(), null));
      iv := new INFOVAR(TYPE^type, PARF^hdep);
      --PARF^tds.inserer(ident^txt,iv);
      PARF^hparams.ajouterParametre(ident^txt,iv); 
    else
        error(parametre_existe_deja, ident^txt);
    end
    PARF^dep:= new Emplacement (PARF^hdep.getDep() - TYPE^type.getTaille(), PARF^hdep.getReg());
 end}


-- les types (de base, noms, struct et pointeurs)
TYPE -> STYPE  #htype PTRS #type;
#htype{
do 
    PTRS^htype:= STYPE^type;
    PTRS^hcode := "";
end}
#type {
do
    TYPE^type := PTRS^type;
end}


-- type de base
-- des * pour definir un pointeur
PTRS -> #type;
#type{
do
    PTRS^type := PTRS^htype;
    --PTRS^code := PTRS^hcode ; --PTRS^tam.genIMalloc(PTRS^hdep) pour faire de storei
end}

PTRS -> mult PTRS #type;
--#gencode {
--do
    -- il faut verifié si les params sont déclaré : il faut ajouté un attribut hérité??????-Nader
    --PTRS1^hcode := PTRS^hcode+PTRS^tam.genMalloc(1);
--end}
#type {
do
    PTRS^type := new POINTEUR(PTRS1^type);
--  PTRS^code := PTRS1^code;
end}


-- types de base
STYPE-> void  #type ;
#type{
do
    STYPE^type := new DTYPEImpl("void", 0);
end}

STYPE-> int #type;
#type{
do
    STYPE^type := new DTYPEImpl("entier", 1); 
end}

STYPE-> char #type;
-- nom de type (commence par une majuscule)
#type{
do
    STYPE^type := new DTYPEImpl("char", 1);
  
end}

STYPE -> identc #type;
global
i:INFO;
-- et struct ?
#type{

do
    i := STYPE^tds.chercherGlobalement(identc^txt);
    if i/= null then
    STYPE^type := i.getType();
    else 
      error(type_inconnu,identc^txt);   
    end  
end}

STYPE -> struct #1 aco CHAMPS acf #2  ;
global
lt : LCHAMPS;
#1{
do
    lt := new LCHAMPS();    
    CHAMPS^champs :=lt;
    CHAMPS^hdep:= STYPE^hdep;
    
end}
#2{
do
    STYPE^type := new STRUCT(lt);
end}
 
CHAMPS -> #dep ;
#dep{
do
    CHAMPS^dep:=CHAMPS^hdep;
end}

-- un nom de champ commence par une minuscule
CHAMPS -> CHAMP #4 CHAMPS #5 ;
#5{
do
    CHAMPS^dep:= CHAMPS1^dep;
end}
#4{
do
    CHAMPS1^hdep:=CHAMP^dep;
end}

CHAMP -> TYPE ident pv #3;
#3{
local
it:CHAMP;
do
        it:=CHAMP^champs.chercher(ident^txt);
        if (it/=null) then
           error(ident_existe_deja,ident^txt);        
        else
        it:= new CHAMP(ident^txt, TYPE^type, CHAMP^hdep);
        CHAMP^champs.inserer(it);
        CHAMP^dep:= new Emplacement (CHAMP^hdep.getDep() + TYPE^type.getTaille(), CHAMP^hdep.getReg());     
        end
end}



-- corps de fonction et bloc d'instructions
BLOC ->  aco #tds INSTS #type acf;
-- instructions
#tds{
local
i : INFOFONC;
do
    i := BLOC^infonc;
    if i /= null then
        INSTS^tds := BLOC^infonc.getTDS();
    else 
        INSTS^tds := BLOC^tds;
    end
        
end
}
#type{
do
  BLOC^type := INSTS^type;
  BLOC^code := INSTS^code; 
  BLOC^dep:=INSTS^dep;
end
}


INSTS -> #gen  ;
#gen{
do 
  INSTS^type:=new DTYPEImpl("void",0);
  INSTS^code:="";
  INSTS^dep:=INSTS^hdep;
end}


INSTS -> #htype INST #hdep INSTS #gen  ;
-- declaration de variable locale avec ou sans init 
#htype{
do
    INST^hdep:=INSTS^hdep;
end}
#hdep{
do
  INSTS1^hdep:=INST^dep;
end}
#gen{
local
    s : STRING;
do
    s := INST^type.getNom();
    if s.equals("void")then
        INSTS^type := INSTS1^type;
    else
        INSTS^type := INST^type; --type de premier INST non void rencontre
    end
    INSTS^dep:=INSTS1^dep;
    INSTS^code:=INST^code + INSTS1^code;  
end}


INST -> TYPE ident #hAFFX AFFX pv #tds ;
#hAFFX{
do
    AFFX^htype := TYPE^type;
end}
#tds{
local
    i: INFO;
    i2: INFOVAR;
    t:DTYPE;
do
 
   
    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= null then
      error(ident_existe_deja, ident^txt);
      
    --elseif (AFFX^type.getNom() /= "void" || TYPE^type.compareTo(AFFX^type) = false) then -- solution : si AFFX^type = void, c-est-a dire qu'on a fait une declaration sans l'affecter, ce qui n'est pas une erreur-Leonardo
    --error(pas_meme_type, TYPE^type, AFFX^type); --bon affichage de l'erreur
    else
        -- defintion d'un nouveau type 
        i2:= new INFOVAR(TYPE^type,INST^hdep);
        INST^tds.inserer(ident^txt,i2);  
        INST^dep:= new Emplacement(INST^hdep.getDep() + TYPE^type.getTaille(), INST^hdep.getReg());
        INST^type := TYPE^type;
        match TYPE^type with POINTEUR then
            t:= TYPE^type.getType();
            INST^code := INST^tam.genMalloc(t.getTaille());
        else
            INST^code := INST^tam.genDecl(ident^txt, i2, AFFX^code);
        end
    end
end
}


-- instruction expression (affectation et appel de procedure)
INST -> #params E pv #r ;
#params{
do
    E^hparams:=new PARAMETRES();
    INST^dep:=INST^hdep;
 
end}
#r{
do
    INST^type := new DTYPEImpl("void", 0);
    --if (E^type.getAffectable() = false && E^type.getNom() /= "void") then -- le seul cas ou on peut executer une expression est si elle est une  appel a fonction Leonardo
    --    error(pas_instruction, E^type);
   -- end
    INST^code := E^code;
    INST^dep := new Emplacement(INST^hdep.getDep() + E^type.getTaille(), INST^hdep.getReg());
end}


-- bloc d'instructions
INST -> #tds BLOC #type  ;
#tds{
do
    BLOC^tds := new TDS(INST^tds);
    BLOC^hdep:=INST^hdep;
    BLOC^infonc:= null;
end
}
#type{
do
    INST^type := BLOC^type;
    INST^dep:=BLOC^dep;
    INST^code := BLOC^code;
end}


-- conditionnelle
INST ->   si paro #hE E parf #tds BLOC SIX #gen ;
#hE {
do
    E^hparams := new PARAMETRES();
end
}
#tds{
do
    BLOC^tds := new TDS(INST^tds);
    SIX^tds := new TDS(INST^tds);
    BLOC^hdep:=INST^hdep;
    SIX^hdep:=INST^hdep;
    BLOC^infonc:= null;
end}
#gen {
do
   if E^type.compareTo(new DTYPEImpl("entier", 1)) then
            INST^type := BLOC^type;
            INST^code := INST^tam.genIf(E^code, BLOC^code, SIX^code);
            -- elseif  ~(BLOC^type.compareTo(INST^htype))  then
            --error(deux_type_diff, BLOC^type);
   -- elseif  ~(SIX^type.compareTo(INST^htype)) then
            --error(deux_type_diff, SIX^type);
    else 
         error(la_condition_pas_reel, E^type);
end
INST^dep:=new Emplacement(BLOC^dep.getDep()+SIX^dep.getDep(), BLOC^dep.getReg());
end}

SIX ->   sinon #hdep BLOC #r ;
#hdep{
do
    BLOC^hdep:=SIX^hdep;
    BLOC^infonc := null;
end}
#r {
do
   SIX^type := BLOC^type;
   SIX^dep:=BLOC^dep;
   SIX^code := BLOC^code; 
end}   

SIX -> #type;
#type{
do
     SIX^type := new DTYPEImpl ("void",0);
     SIX^dep:=SIX^hdep;
     SIX^code := "";
end}

-- retour de fonction
INST ->  retour  #hparam E pv #r ;
#hparam{
do 
    E^hparams:=new PARAMETRES();
end}
#r{
do
     INST^type := E^type;
     INST^dep:=new Emplacement(INST^hdep.getDep()+E^type.getTaille(), INST^hdep.getReg());
     INST^code := E^code + INST^tam.genRetour("A completer");   -- code : empiler E 
end}


-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------
E ->  #h0 A #h AFFX #r ;
#h0{
do
    A^valeurchargee := false;
end
}
#h {
do
    AFFX^htype := A^type;
end}
#r{
do
 if AFFX^type.compareTo(new DTYPEImpl("void", 0)) then
     E^type := A^type;  
     E^code := A^code + AFFX^code;
 elseif A^type.compareTo(AFFX^type) then
     E^type := A^type;
     E^code := AFFX^code  + A^code;-- +  E^tam.genWriteIndirectMem(A^type.getTaille()); 
     
 else
      error(pas_meme_type, A^type, AFFX^type); 
   
 end
end}

AFFX -> affect #h A #r;
#h{
do
    A^valeurchargee := true;
end
}
#r{
do
    AFFX^type:=A^type;
    AFFX^code := A^code +  AFFX^tam.genWriteIndirectMem(A^type.getTaille());
    
end}


AFFX -> #gen;
#gen {
do
    AFFX^type := new DTYPEImpl("void", 0);
    AFFX^code := "";
end
}

-- relation
A ->   R AX #r;
#r{
do
 if AX^type.compareTo(new DTYPEImpl("void", 0)) then
     A^type := R^type;   
     A^code := R^code;
 elseif R^type.compareTo(AX^type) then
     A^type := R^type;
     A^code := R^code + AX^code;
 else
      error(pas_meme_type, R^type);
 end
end}

AX -> OPREL R #r;
#r{
do
    if R^type.compareTo(new DTYPEImpl("entier",1)) || R^type.compareTo(new DTYPEImpl("char",1))  then 
        AX^type:=R^type;
        AX^code := R^code + OPREL^code;
    else
        error(pas_reel, R^type); 
 end
end}
 
AX -> #r ;
#r{
do
    AX^type:=new DTYPEImpl("void",0);
    AX^code := "";
end} 
 

-- operateurs relationnels
OPREL -> inf #gen;
#gen{
do
    OPREL^code := "\tSUBR Lss \n";
end}

OPREL -> sup #gen;
#gen{
do
    OPREL^code := "\tSUBR iGtr \n";
end}

OPREL -> infeg #gen;
#gen{
do
    OPREL^code := "\tSUBR iLeq \n";
end}

OPREL -> supeg #gen;
#gen{
do
    OPREL^code := "\tSUBR iGeq \n";
end}

OPREL -> eg #gen;
#gen{
do
    OPREL^code := "\tSUBR ieq \n";
end}

OPREL -> neg #gen;
#gen{
do
    OPREL^code := "\tSUBR iNeq \n";
end}

R ->  T  RX #r ;
#r{
do
 if RX^type.compareTo(new DTYPEImpl("void", 0)) then
     R^type := T^type; 
     R^code := T^code ;
 elseif RX^type.compareTo(T^type) then
     R^type := T^type;
     R^code := T^code + RX^code;
     
 else
      error(add_type_diff, T^type); 
 end
end}


-- additions ...
RX ->   OPADD  T RX #r ;
#r{
do
    if T^type.compareTo(new DTYPEImpl("entier",1))  then   
      
          RX^type := T^type;
          RX^code := T^code + RX1^code + OPADD^code;
      
    else
  error(add_non_reels, T^type); 
 end
end}

RX -> #r ;
#r{
do
    RX^type:=new DTYPEImpl("void",0);
    RX^code := "";
end}
 

-- operateurs additifs
OPADD -> plus #gen;
#gen{
do
    OPADD^code := "\tSUBR IAdd \n";
end}

OPADD -> moins #gen;
#gen{
do
    OPADD^code := "\tSUBR ISub \n";
end}

OPADD -> ou #gen;
#gen{
do
    OPADD^code := "\tSUBR Or \n";
end}


-- multiplication, ...
T -> #h F  TX #r ;
#h{
do  --A corriger/Modifier
  F^hparams:=new PARAMETRES();
  F^hcode := "";
end
}
#r{
do
 if TX^type.compareTo(new DTYPEImpl("void", 0)) then
     T^type := F^type;  
     T^code := F^code ;
 elseif TX^type.compareTo(F^type) then
     T^type := F^type;
     T^code := F^code + TX^code;
 else
      error(mulTypes_diff, F^type); 
 end
 

end}

TX ->   OPMUL   #hp F TX #r ;
#hp{
do --A corriger/Modifier
  F^hparams:=new PARAMETRES();
  F^hcode := "";
  --F^hadresse := -1;
     
 
end
}
#r{
do
    if F^type.compareTo(new DTYPEImpl("entier",1)) then
       
          TX^type := F^type;
          TX^code := F^code +  TX1^code + OPMUL^code;
    
    else
     
        error(pas_reel, F^type); 
 end

end}
 
TX ->  #r ;
#r{
do
    TX^type:=new DTYPEImpl("void",0);
    TX^code := "";
 end}
 
 
-- operateurs multiplicatifs
OPMUL -> mult #gen ;
#gen{
do
    OPMUL^code := "\tSUBR IMul \n";
end}

OPMUL -> div #gen ;
#gen{
do
    OPMUL^code := "\tSUBR IDiv \n";
end}

OPMUL -> mod #gen ;
#gen{
do
    OPMUL^code := "\tSUBR IMod \n";
end}

OPMUL -> et #gen ;
#gen{
do
    OPMUL^code := "\tSUBR And \n";
end}


-- expressions de base
-- Constante entiere
F -> entier #type;
#type{
do
   F^type := new DTYPEImpl("entier", 1);
   F^code := F^tam.genCst(entier^txt);
   
   F^code_est_adresse := false;
   F^adresse := -1;
end}  

-- Constante chaine
F -> chaine #type;
#type{
do
   F^type := new DTYPEImpl("string", 1); -- F^type := new DTYPEImpl("entier", 1); ca peut pas etre un entier !! Leonardo
   F^code := F^tam.genCst(chaine^txt); 
   F^code_est_adresse := false;
   F^adresse := -1;
end}  

-- Constante caractere
F -> caractere #type;
#type{
do
   F^type := new DTYPEImpl("char", 1); -- F^type := new DTYPEImpl("entier", 1); ca peut pas etre un entier !! Leonardo
   F^code := F^tam.genCst(caractere^txt); 
   F^code_est_adresse := false;
   F^adresse := -1;
end}  

-- expression unaire
F ->  OPUN  F  #gen;
#gen{
do
    F^type := F1^type;
    F^code := F1^code + OPUN^code;
    F^code_est_adresse := false;
    F^adresse := -1;
end}


-- operateurs unaires
OPUN -> plus #gen;
#gen{
do
    OPUN^code  := "\tSUBR Add \n";
end}

OPUN -> moins #gen;
#gen{
do
    OPUN^code  := "\tSUBR Sub \n";
end}

OPUN -> non#gen;
#gen{
do
    OPUN^code  := "\tSUBR Not \n";
end}

-- pointeur NULL
F -> null  #gen;
#gen{
do
   F^type := new DTYPEImpl("void",1);
   F^code_est_adresse := false;
   F^adresse := -1;
   F^code := "";
end}


-- expression parenthesee
F ->  paro E parf #h FX #gen;
#h{
do
    FX^hcode_est_adresse := true;
    FX^htype:=E^type;
    FX^hadresse:= E^type.getTaille();
end
}
#gen{
do
    F^type := FX^type;
    F^code_est_adresse := true; -- ??
    F^adresse := FX^adresse;
    F^code := FX^code;
end
} 

F -> paro #dep TYPE parf  F #gen;      --cast ??? nader
#dep{
do
    TYPE^hdep := new Emplacement(0, new Register("SB", 0));   --classe Emplacement dans mcsgc | Pas d'emplacements pour un type (Maxime)
end}
#gen{
do
    --if F1^type.compareTo(TYPE^type) then  -- Pour l'instant on ne gère pas le cast
        F^type := TYPE^type;
        F^code_est_adresse := F1^code_est_adresse ;
        F^adresse := F1^adresse;
        F^code := F1^code;
    --else
    --    error(Wrong_Type, F1^type);
    --end
end}

F -> mult F #gen;
#gen {
local
    c : DTYPE;
do
    c := F1^type;
    match c with POINTEUR then
        F^type := c.getType();
        F^code_est_adresse := true;
        F^code :=  F1^code;
        F^adresse := F1^adresse;  
    else 
        error(pas_un_pointeur, F1^type);
    end
end}

F -> ident #h FX #gen;
global 
  c : DTYPE; 
  i : INFO;
  iv : INFOVAR;
  e : Emplacement;
 --p:POINTEUR;
  --t:DTYPE;
#gen {
do
    i := F^tds.chercherGlobalement(ident^txt);
    if i /= null then
        match i with INFOVAR then
            iv := i;
            c := i.getType();
            match c with POINTEUR then
                F^code_est_adresse := true;
                F^code := FX^code  ;
            else
                F^code :=  "";
            end
            F^type := FX^type;
            F^adresse := iv.getDep() + FX^adresse;
        end
        match i with INFOFONC then
            c := i.getType();
            F^type := c;
            F^code_est_adresse := true; --Le code de f envoie vers l'emplacement de la fonction ? 
            F^code:= FX^code + F^tam.genCall("_"+ident^txt);
            e :=i.getEmpl();
            F^adresse := e.getDep();
        end
    end
end}
#h {
do
    i := F^tds.chercherGlobalement(ident^txt);
    if i /= null then
        match i with INFOVAR then
            c := i.getType();
            iv := i;
            --match c with POINTEUR then
            --t:=c.getType();
             -- FX^htype := t;
            --else         
                FX^htype:=c; 
                write iv + " ";
                if !F^valeurchargee then
                    FX^hcode := F^hcode + F^tam.genReadMem(iv.getDep(), c.getTaille());
                else 
                    FX^hcode := F^hcode +  F^tam.genReadIndirectMem(1);
                end
            --end
            end
  FX^hcode_est_adresse := false;
  FX^hadresse := -1;
            end     
end}

FX ->#gen ;
#gen {
do
  FX^type := FX^htype;
  FX^code_est_adresse := FX^hcode_est_adresse;
  FX^code :=FX^hcode;
  FX^adresse := FX^hadresse;
end}

-- acces champ
FX -> pt ident #h FX  #gen;
#h {
local
 s : STRUCT ;
 c : CHAMP;
 lc : LCHAMPS;
 p: POINTEUR;
 t : DTYPE;
do 
  match FX^htype
  with POINTEUR then
    p := FX^htype;
    t := p.getType();
    match t 
    with STRUCT then
        s := t;
        --s := FX^htype;
        lc := s.getChamps();
        c := lc.chercher(ident^txt);
        if c = null then
          error(Unaffected_ident, ident^txt) ;
        else
            FX1^htype := c.getType();
            if FX^hadresse = -1 then
                FX1^hadresse := -1;
                FX1^hcode := FX^hcode + FX^tam.genComment("acces champ : " + ident^txt) +
                  FX^tam.genAdrField(c.getEmpl())  ;
            else
                FX1^hadresse :=  FX^hadresse + c.getDep();
                FX1^hcode := FX^tam.genComment("acces champ : " + ident^txt);
            end
        end  
     end   
  else
    error(Wrong_Type, FX^htype);
  end
end}
#gen {
do
    FX^type := new POINTEUR(FX1^type);
    FX^code_est_adresse := true;
    FX^code :=FX1^code;
    FX^adresse := FX1^adresse;
end}


-- acces champ pointeur
FX ->   arrow  ident #h FX  #gen;
#h {
local
 s : STRUCT ;
 c : CHAMP;
 lc : LCHAMPS;
 p: POINTEUR;
 t:DTYPE;
do
  match FX^htype
  with POINTEUR then
    p := FX^htype;
    t := p.getType();
      match t 
      with STRUCT then
        s:=t;
        --s := FX^htype;
        lc := s.getChamps();
        c := lc.chercher(ident^txt);
        if c = null then
          error(Unaffected_ident, ident^txt) ;
        else
          FX1^htype := c.getType();        
          FX1^hcode_est_adresse := false;
          FX1^hcode := FX^hcode +  FX^tam.genAdr(c.getEmpl()) ;
        end    
      end
  else
    error(Wrong_Type, FX^htype);
  end
end}
#gen {
do
  FX^type := FX1^type;
  FX^code_est_adresse := true;
  FX^code :=FX1^code;
  FX^adresse := FX1^adresse;
end}


-- appel de sous-programme
FX ->   paro ES parf FX  #gen; --Verifier les parametres A ce niveau ??
#gen {
do
  FX^type := FX1^type;
  FX^code_est_adresse := true;
  FX^code :=ES^code + FX1^code ;
  FX^adresse := FX1^adresse;
end}


-- arguments appel de sous-programme
ES -> #p;
#p{
do
    ES^params := new PARAMETRES();
    ES^code := "";
  
end}

ES -> #init E ESX #gen;
#init{
local
   p : PARAMETRES;
do
    p := new PARAMETRES();
    E^hparams := p;
    ESX^hparams := p;
end}
#gen{
do
    ES^params := ESX^params;
    ES^code := ESX^code+ E^code  ;
    
end}

ESX ->  #gen ;
#gen{
do
   ESX^params:= ESX^hparams;
   ESX^code := "";
   end}

ESX -> virg E ESX #gen ;
#gen{
do
   ESX^params:=ESX1^params;
   ESX^code := ESX1^code + E^code;
  
end}

------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur T+++++++AM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := ENTITE^tds; 
  ENTITE^dep :=  ENTITE^hdep;
end}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
  ENTITE^code := ASM^code_asm;
end}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := INST^tds;
  INST^dep:=INST^hdep;        --nader
end}
#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
  INST^dep:=INST^hdep;      --nader
  INST^code := ASM^code_asm;
  INST^type := new DTYPEImpl("void", 0); -- si il ya du code assembleur le type de retour est void
end}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------

TYPE -> bool #type;
#type {
do
    TYPE^type := new DTYPEImpl("booleen", 1);
end
}

-- definit un contenu d'un namespace
ENTITE -> namespace identc #tds aco ENTITES acf #gen;
global
    pace : ArrayList<NAMESPACE> ;
    ns : NAMESPACE;
    --ns2 : NAMESPACE;
    --tds2 : TDS;
    --tds3 : TDS;
#tds{
local
    i : INFO;
    nmtds : TDS;
    g : boolean;
do
    i := ENTITE^tds.chercherNs(identc^txt);
    if i=null then
        nmtds := new TDS();
        ns := new NAMESPACE(nmtds, identc^txt);
        ENTITE^tds.insererNs(ns);
        ENTITES^tds:= nmtds;
        pace := ENTITE^tds.getListNs();
        ns := pace.get(0);
        --write ns.getActive() + "\n";
    else 
        error(ns_existe, identc^txt);
    end
end
}
#gen {
do
    ENTITE^dep := ENTITES^dep;
    ENTITE^code := ENTITES^code;
end
}


-- donne l acces au contenu du 'namespace'
ENTITE -> using identc #h IDC #tds pv #gen;
#h {
local
    i : INFO;
    ns : NAMESPACE;
do
    
    --write identc^txt + "\n";
    i := ENTITE^tds.chercherNs(identc^txt);
    match i with
    NAMESPACE then 
        ns := i;
        IDC^hnms := ns ;
        IDC^hname := null;
    else
        error(no_nms, identc^txt); 
    end   
end}
#tds {
local
   nom : String;
   ns : NAMESPACE;
do
    ns := IDC^nms;
    ENTITE^code:="";
    ENTITE^dep:=ENTITE^hdep;
    ns.Active2true();
    ENTITE^tds.insererNs(ns);
end
}
#gen {
do
    --write "test" + IDC^nms.getActive() + "\n";
    ENTITE^dep := new Emplacement(0, null);
    ENTITE^code := "";
end
}


IDC -> #h ;
#h {
do
    IDC^nms := IDC^hnms;
    IDC^name := IDC^hname;
end
}


IDC -> pt identc #h IDC #gen ;
#h {
local
    tds : TDS;
    i: INFO;
do
    tds := IDC^hnms.getNstds();
    i := tds.chercherNs(identc^txt);
    match i with
    NAMESPACE then 
        IDC1^hnms := i ;
    end
    i := IDC^tds.chercherGlobalement(identc^txt); --pas sur si globalement ou localement
    match i with INFOCLASSE then
        IDC1^hname := i;
    else
        error(no_nms, identc^txt);  
    end 
end
}
#gen {
do
    IDC^nms := IDC1^nms;
    IDC^name := IDC1^name;
end
}


-- definition d'une classe (peut etre en dehors d'un namespace)
ENTITE -> ACCES class identc HERITAGE #1 aco DEFS acf #gen;
global
    tds:TDS;
#1{
local
	i:INFO;
	tv_etiq :String;
	attribut : ArrayList<String>;
	tv:  ArrayList<String>;
do
	i:= ENTITE^tds.chercherGlobalement(identc^txt);
	if (i/=null) then 
	   error(no_nms, identc^txt);
	else
		tds := new TDS(ENTITE^tds);
		attribut := new ArrayList<String>();
		tv := new ArrayList<String>();
		tv_etiq := ENTITE^tam.genEtiq();
		tv.add(tv_etiq);
		i:= new INFOCLASSE(tds,attribut,tv,null,identc^txt,HERITAGE^name,ACCES^acc);
		ENTITE^tds.inserer(identc^txt,i);
		DEFS^tds:=tds;
		DEFS^hattribut:=attribut;
		DEFS^htv:=tv;
    end
end}
#gen{
do
	ENTITE^dep:=DEFS^dep;
    ENTITE^code:= ENTITE^tam.genTv(DEFS^tv) + DEFS^code;
end}


-- acces 
ACCES -> public #1;
#1{
do
    ACCES^acc := "public";
end}


ACCES -> private #2;
#2{
do
    ACCES^acc := "private";
end}


ACCES -> #3 ;
#3{
do
    ACCES^acc := "";
end}


-- heritage
HERITAGE -> #name ;
#name{
do
HERITAGE^name:=null;
end}


HERITAGE -> dpts identc #name2 IDC #name1 ;
#name1{
local
do
    HERITAGE^name := IDC^name;
end}
#name2{
local
    i : INFO;
do
    IDC^hnms := null;
    i := HERITAGE^tds.chercherGlobalement(identc^txt);
    match i with INFOCLASSE then 
        IDC^hname := i;
    else
        error(no_classe,identc^txt);
    end
end
}

-- membres d'une classe
DEFS -> #gen;
#gen{
do
	DEFS^code:="";
	DEFS^dep:=DEFS^hdep;
	DEFS^tv:=DEFS^htv;
end}


DEFS ->  ACCES #1 DEF #2 DEFS #gen;
#1{
do
    DEF^hdep:=DEFS^hdep;
end}
#2{
do
    DEFS1^hdep:=DEF^dep;
end}
#gen{
do
	DEFS^code:=DEF^code + DEFS1^code;
	DEFS^dep:=DEFS1^dep;
	DEFS^tv:=DEFS^htv;
end}


DEF  ->  TYPE ident #tds DECL #gen ;
#tds{
local 
    i: INFO;
do
    DECL^declid:=ident^txt;
    DECL^declt:=TYPE^type;
    DECL^tds:=DEF^tds;
    DECL^hdep:=DEF^hdep;
    
    i := DEF^tds.chercherLocalement(ident^txt);
    if i /= null then
       match i
           with INFOFONC then
               error(Fonction_existe_deja, ident^txt); -- il s'agit d'une fonction donc traitement de la surcharge (nombre de paramétres différents avec le meme nom de fonction)
           else 
               error(ident_existe_deja, ident^txt);
       end                                    
    end
end}
#gen{
do
    DEF^dep:= DECL^dep;
    DEF^code :=DECL^code;  -- ENTITE^code:= "" modifie, avant ça devienait le code vide Leonardo
end
}


-- constructeur
DEF  ->  identc  paro #params PARFS parf BASE #1 BLOC #gen;
#1{
local
i:INFO;
tds:TDS;
const:INFOFONC;
tv:ArrayList<String>;
t:DTYPE;
do
 t:=new DTYPEImpl("void",1); 
 i := DEF^tds.chercherGlobalement(identc^txt);
    match i with INFOCLASSE then
    -- BASE^mere :=i;
       tds:=new TDS(DEF^tds);
       const:= new INFOFONC(t,null,PARFS^params,tds);
       write "const  " + const;
       BLOC^infonc:=const;
       DEF^tds.inserer(identc^txt,const);
       tv:= i.getTv();
       tv.add(identc^txt); 
       BLOC^hdep := new Emplacement(DEF^hdep.getDep(), new Register("LB",5));
    
    else
     error(Fonction_existe_deja, identc^txt);
    end
end}
#gen{
do
    DEF^dep:=BLOC^dep;    
    DEF^code := DEF^tam.genFonction(identc^txt, 0, BLOC^type.getTaille(),BLOC^code); --A completer : enregistrer le type de retour
    write "\n **" + identc^txt  + " " +  BLOC^code;
end}
#params {
do
PARFS^hparams := new PARAMETRES();
PARFS^hdep:= new Emplacement (-1, new Register("LB",5));
end} 


-- appel eventuel au constructeur de la classe parente.
BASE -> ;

BASE -> dpts base paro #params ES parf;
#params{
do
ES^hparams:=new PARAMETRES();
end}


-- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
PARF ->  MODE TYPE ident#tdstype;
#tdstype{
local
    t : DTYPE;
    iv : INFOVAR;
do
    iv := PARF^hparams.getParametre(ident^txt);
    --t := iv.getType();
    if (iv = null) then
      -- iv := new INFOVAR(TYPE^type, new Emplacement(TYPE^type.getTaille(), null));
      iv := new INFOVAR(TYPE^type, PARF^hdep);
      --PARF^tds.inserer(ident^txt,iv);
      PARF^hparams.ajouterParametre(ident^txt,iv); 
    else
        error(parametre_existe_deja, ident^txt);
    end
    PARF^dep:= new Emplacement (PARF^hdep.getDep() - TYPE^type.getTaille(), PARF^hdep.getReg());
 end}


MODE -> ref ;
MODE -> out ; 


F -> true #type;
#type{
do
   F^type := new DTYPEImpl("booleen", 1);
   F^code := F^tam.genCst("1");
   F^code_est_adresse := false;
   F^adresse := -1;
end}  


F -> false #type;
#type{
do
   F^type := new DTYPEImpl("booleen", 1);
   F^code := F^tam.genCst("0");
   F^code_est_adresse := false;
   F^adresse := -1;
end}  




F -> this #h FX #type;
#type{
do
   F^type := FX^type;
   F^code := FX^code; ---    a traiter mohamed ali
   F^code_est_adresse := false;
   F^adresse := -1;
   
end}  
#h{
do
    FX^htype:= null; 
    FX^hcode_est_adresse := false;
    FX^hadresse := -1;
end}


F -> base #h FX #type;
#type{
do
   F^type := FX^type;
   F^code := FX^code;
   F^code_est_adresse := false;
   F^adresse := -1;
   F^code_est_adresse := false;
end}  
#h{
do
	FX^htype:=null;
	FX^hcode_est_adresse := false;
	FX^hadresse :=-1;
end}


F -> null2 #gen;
#gen{
do
   F^type := new DTYPEImpl("void",1);
   F^code_est_adresse := false;
   F^adresse := -1;
   F^code := "";
end}


F -> new identc #h IDC paro ES parf #gen;
#gen{
local
	i:INFO;
	tv : ArrayList<String>;
	attribut : ArrayList<String>;
	tv_etiq : String;
    num : int;
do
i := F^tds.chercherGlobalement(identc^txt);
    match i with INFOCLASSE then
    --IDC^hnms:=null;   
    attribut:=i.getAttribut();
    tv := i.getTv(); 
    tv_etiq:= tv.get(0);
    num := tv.indexOf(identc^txt)-1;
    F^code:= F^tam.genMalloc(attribut.size()) + "\n STORE (1) 0[SB] \n"  +  ES^code + "\n LOADA " + "_"+ tv_etiq + "\n LOADL " + num + "\n SUBR Iadd \n CALLI \n";  
    
    else
     error(classe_existe_pas, identc^txt);
    end
 F^type := new DTYPEImpl("void",1);
 F^code_est_adresse := false;
 F^adresse := -1;
end}
#h{
local i : INFO;
do
	IDC^hnms:=null;
	i := F^tds.chercherGlobalement(identc^txt);
	match i with INFOCLASSE then
	   IDC^hname := i;
    end   
end}


end